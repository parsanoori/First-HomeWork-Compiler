%نام و نام خانوادگی:
%شماره دانشجویی: 
\مسئله{نام سؤال}


\پاسخ{}

الف) خیر کامپایلر از زبان سطح پایینتر به بالاتر نیز (همان دیکامپایل) و همچنین کامپایلر های زبان نرم افزار به سخت افزار هم داریم.

ب) در زبان های پویا کامپایل کردن سریع تر و عملکرد در زمان اجرا کند تر است. \newline
این برای آن است که کامپایلر بخشی از کارهایش را به زمان اجرا واگذاز میکند. پس کار های کمتری انجام داده و کند تر است. از طرفی در زمان اجرا این کار ها همچون link کردن باید انجام شود. که باعث میشود زمان اجرا کند تور شود.\newline
اگر بیایم برض کنیم که میخواهیم foo.bar() را اجرا کنیم باید ابتدا در \lr{Hash Table} دنبال foo بگردیم و بعد در \lr{Hash Table} مربوط به foo به دنبال آدرس bar(). این در حالی است که در رویکرد کامپایلری ما در جا آدرس foo و سپس در جا آدرس bar() را داریم. و دیگر نیازی به استفاده از \lr{Hash Table} نیست. از طرفی نیز در این رویکرد یک لایه باید برای ما خود بیاید و چیزی مثل بایت کد را به کد ماشین انجام دهد و این کار ممکن است تنها یک بار انجام نشود بلکه چند بار انجام شود(البته اگر بهینه سازی JIT انجام نشود که دور از ذهن نیست). این کارایی و سرعت را برای ما به شدت کاهش میدهد به قسمی که کل فرایند تبدیل کد سطح بالا تا کد ماشین ممکن خیلی خیلی و تا ۵۰ برابر کند ر از زبان های کامپایل شده انجام بشود. \newline

ج) 

\begin{latin}
\begin{tikzpicture}

    \node[state,initial] (q0) {$q_0$};
    \node[state,right of=q0] (q1) {$q_1$};
    \node[state,below of=q1] (q2) {$q_2$};
    \node[state,right of=q1,accepting] (q3) {$q_3$};

    \draw (q0) edge[above] node{T\_"} (q1);
    \draw (q1) edge[bend right] node[left]{'\textbackslash'} (q2);
    \draw (q2) edge[bend right] node[right]{'n','t','"'} (q1);
    \draw (q1) edge[loop above] node{$\Sigma$ - \{'\textbackslash','"'\}} (q1);
    \draw (q1) edge[above] node{T\_"} (q3);

\end{tikzpicture}
\end{latin}
